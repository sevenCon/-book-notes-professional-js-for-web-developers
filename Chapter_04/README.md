# Chapter 04 变量作用域，和内存问题

### 基本类型和引用类型的值
##### 变量引用赋值和基本类型赋值
 
```
    //基本类型赋值
    var num1 = 5;
    var num2 = num1;
    num2 = 1;
    console.log(num1);//5

    //复杂类型赋值
    var obj1 = new Object();
    var obj2 = obj1;
    obj1.name = 1;
    console.log(obj2.name);// 1;
```

如上，基本类型赋值，则是把值复制一份，放到另一个储存空间，而复杂类型赋值，则是简单的共用一个储存空间，原理则是将引用到真正储存值的地址引用赋值到新的变量。
 

##### 参数的引用赋值

js中的参数的传递，是按照值传递的，也就是利用传入的变量的值，复制一份，再赋值给参数的变量，参数的变量，和外部传入的变量，在基本类型中，是不同地址引用，储存相同的值，在复杂类型中，赋值的是对象的地址指针，指针引用的是同一个对象地址，在参数内部对对象（引用）进行操作，外部用另一个引用访问的对象也会变化，也即是两个引用，指向的是同一个对象。
```
    //基本类型的函数按值传递
    function addTen(num){
        num += 10;
        retrun num;
    }

    var count = 10;
    var result = addTen(count);
    console.log(count);//10 不变
    console.log(result);//20

    //复杂类型的函数参数按值传递
    function setName(obj){
        obj.name = "Nicholas";
    }
    var person = new Object();
    setName(person);
    console.log(person.name); // "Nicholas"  ,改变

```

##### 4.1.4 类型检测

对于基本的类型检查，typeof 操作符可以用在Undefined,Null,Number,Boolean,String等基本的类型，器返回值，分别是undefined,null,number,boolean,string,对与复杂的类型，返回值则不同，function,object等

```
    console.log(typeof 1); // number
    console.log(typeof "12"); //string
    console.log(typeof a);  //undefined
    console.log(typeof null);  // object
    console.log(typeof function(){}); // function
    console.log(typeof {});  //object
```

>note: typeof null,返回的是一个对象，用typeof null === 'object '，是因为
检查object的时候，返回JS类型值是存在32 BIT 单元里,32位有1-3位表示TYPE TAG,其它位表示真实值而表示object的标记位正好是低三位都是0000: object. The data is a reference to an object.
而js 里的Null 是机器码NULL空指针, (0x00 is most platforms).所以空指针引用 加上 对象标记还是0,最终体现的类型还是object.


##### 4.2 执行环境及作用域
代码在一个环境中执行的时候，会创建一个作用域链，作用域链的作用是保证对执行环境的有权访问所有变量，和函数的有序执行。
作用域的前端，永远是当前的执行环境的变量对象，作用域最开始时，只有一个对象，argumets对象，而下一个对象，则是外部的环境对象，一直延续到全局执行环境。

##### 延长作用域
执行环境的类型，分为局部和全局作用域。但是在一个作用中还是有办法去延长一个作用域
- with
- try-catch，catch会抛出一个错误的对象，在错误对象可以访问错误声明
with 语句可以强制的引入一个变量环境，例如
```
    function buildUrl(){
        var qs = "?debug=true";
        with(location){
            var url = href + qs;
        }
        return url;
    }
```
引入的location的语句块中，href 和 qs 都会去location的对象，当前的函数作用域中去寻找，若是找不到，则再往上一级的作用域中寻找，造成标示符在检索范围变大，大规模的使用会导致性能降低，js引擎在优化标示符查询方面还是做的挺好。

##### 垃圾收集
js的内存是自动分配的，不会像c/c++,需要开发人员手动的管理内存变量。在js中有，2种垃圾收集的方案。
- 标记清除，是目前的主要的使用的方案，在变量进入环境和离开环境时做标记的方法，去释放变量。垃圾收集器在运行的时候，会给所有的变量打上标记，然后再去除环境中的变量，和被环境中变量引用的变量的标记，而依然被标记上的变量则标为预备删除的变量，原因是环境中变量已经无法访问这些变量了。最后垃圾收集器回收内存。
- 引用计数，则是通过引用一个变量一次，则给计数+1的方式，通过计数去追踪每个值被引用的次数，当声明了一个变量，并将一个引用类型赋给该变量时，这个值的引用次数+1，而同一个值被赋给另一个变量，则该值引用次数+1，相反，如果包含该值的变量取得了另一个值，则该值的引用次数变为-1，当该值的引用变为0的时候，说明已经没有办法去获取这个值了，就把这个空间回收，下次垃圾收集器运行的时候，就会释放那些引用次数为零的情况。
但是，因为循环引用的问题,这个bug没有得到解决，所以没有继续下去
```
    var obj1 = new Object();
    var obj2 = new Object();
    obj1.pram = obj2;  // obj2 ：1
    obj2.pram = obj1;  // obj1 : 1
```

这个问题在IE9以前的组件 BOM和DOM中的对象，是利用C++的COM编写的，COM就是用的循环引用的垃圾收集，即使ie使用的是标记清除的方法，只要涉及到BOM和DOM的对象，存在循环引用的对象，内存就没有得到回收，IE9BOM和DOM变成了真正的js对象。

##### 内存管理
在桌面引用中，浏览器的内存分配通常会比其他的应用的少，主要为防止内存占用过多，而导致系统崩溃，所以在内存占用过多的情况下，可以通过解除引用的方式去取消较大的占用变量。
```
    var global = {};

    global = null;
```


### 小结
js变量可以用来保存2种类型，基本类型包括null，undefined，boolean，number，string
引用类型则是基本类型的组合。有一下特点：
- 基本类型,null,undefined,string,boolean,number,等占用内存较少且固定，所有被保存在栈空间中
- 从一个变量赋值给另一个变量，会复制一个副本
- 引用类型是对象，保存在堆空间中
- 包含引用类型的变量，实际上保存可以访问该对象的一个指针。
- 从一个对象赋值给另一个变量的过程，实际上只是赋值指针，因此两个变量访问的同一个对象。
- 确定基本类型用typeof，确定是否是哪一个引用类型用instanceof

所有的变量都依赖于一个执行环境当中，执行环境决定变量的生命周期和访问的权限，顺序
- 执行环境分全局环境和局部环境之分
- 每次进入一个新的执行环境，都会生成一个搜索变量和函数的作用域链
- 函数的执行不只是可以访问当前的执行环境，还可以访问父环境，乃至全局环境。
- 全局环境不能访问局部环境变量
- 变量的执行环境决定何时释放变量

js是一门拥有自动内存管理的语言，而不需要开发人员去管理内存
- 离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除
- 标记清除算法是当前主要的垃圾收集算法，思想是通过给不在当前作用域的变量打上标记，然后再删除
- 引用计数的算法现在已经不在使用，其思想是通过跟踪记录所有值被引用的次数，js引擎目前不再使用这种算法，ie9以前的浏览器所用的Bom和Dom则是这种垃圾收集算法。
- 代码中的循环引用问题，会导致引用计数的垃圾收集失效
- 解除引用的方法可以消除引用计数的失效问题，为了有效的内存管理，应即时的解除不在使用的全局对象。